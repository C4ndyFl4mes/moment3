{"mappings":"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","sources":["<anon>","src/scripts/main.js"],"sourcesContent":["(function () {\n\n\nconst $5a3fc3e2587399e4$var$prevBTN = document.getElementById(\"prev-btn\");\nconst $5a3fc3e2587399e4$var$nextBTN = document.getElementById(\"next-btn\");\nconst $5a3fc3e2587399e4$var$searchFIELD = document.getElementById(\"search-field\");\nconst $5a3fc3e2587399e4$var$pageNumberSPAN = document.getElementById(\"page-number\");\nconst $5a3fc3e2587399e4$var$maxPageSPAN = document.getElementById(\"max-pages\");\nconst $5a3fc3e2587399e4$var$animeListDIV = document.getElementById(\"anime-list\");\n// När sidan laddas in hämtas och renderas första sidan av anime listan.\nwindow.onload = async ()=>{\n    if (!sessionStorage.getItem(\"animePagesofLists\")) await $5a3fc3e2587399e4$var$getTopAnime();\n    // Sätter visuellt vilken sida som användaren står på vid inladdning av sidan.\n    if (sessionStorage.getItem(\"page\")) {\n        const pageData = JSON.parse(sessionStorage.getItem(\"page\"));\n        $5a3fc3e2587399e4$var$pageNumberSPAN.innerHTML = pageData.current;\n        $5a3fc3e2587399e4$var$maxPageSPAN.innerHTML = pageData.last;\n    }\n    $5a3fc3e2587399e4$var$renderList();\n};\n// Renderar en sida beroende på vilken sida det är, standard är första sidan.\nasync function $5a3fc3e2587399e4$var$renderList(page = 1) {\n    // Uppdaterar visuellt vilken sida användaren står på.\n    if (sessionStorage.getItem(\"page\")) {\n        const pageData = JSON.parse(sessionStorage.getItem(\"page\"));\n        $5a3fc3e2587399e4$var$pageNumberSPAN.innerHTML = pageData.current;\n        $5a3fc3e2587399e4$var$maxPageSPAN.innerHTML = pageData.last;\n    }\n    if (sessionStorage.getItem(\"animePagesofLists\")) {\n        // Hämtar listan från sessionStorage:\n        const pagesofLists = JSON.parse(sessionStorage.getItem(\"animePagesofLists\"));\n        // Loopar igenom sidorna tills rätt sida är funnen, då anropas listOnPage med sidans lista som argument, därefter stoppas loopen.\n        // Ifall sidlistan inte hittas i arrayen, då hämtas den sidlistan genom att anropa getTopAnime(sidnummer) och därefter renderas den nya sidlistan.\n        for (const list of pagesofLists){\n            if (list.page === page) {\n                $5a3fc3e2587399e4$var$listOnPage(list.list);\n                break;\n            } else if (pagesofLists.indexOf(list) === pagesofLists.length - 1 && list.page !== page) {\n                await $5a3fc3e2587399e4$var$getTopAnime(page);\n                await $5a3fc3e2587399e4$var$renderList(page);\n            }\n        }\n    }\n}\n// Renderar en lista.\nfunction $5a3fc3e2587399e4$var$listOnPage(list) {\n    // Använder innerHTML för att det ska bli så smidigt som möjligt.\n    $5a3fc3e2587399e4$var$animeListDIV.innerHTML = \"\";\n    list.forEach((anime)=>{\n        let title = anime.title_english;\n        if (anime.title_english === null) title = anime.title;\n        $5a3fc3e2587399e4$var$animeListDIV.innerHTML += `<article class=anime-list-item>\n                <h2>${title}</h2>\n                <div>\n                    <picture class=poster>\n                        <source srcset=\"${anime.images.webp.image_url}\" type=\"image/webp\">\n                        <img src=\"${anime.images.jpg.image_url}\" width=\"100\" height=\"141\" alt=\"\" loading=\"lazy\" class=poster>\n                    </picture>\n                    <table class=anime-info-table>\n                        <thead>\n                            <tr>\n                                <th>Rank</th>\n                                <th>Score</th>\n                                <th>Rating</th>\n                            </tr>\n                        </thead>\n                        <tbody>\n                            <tr>\n                                <td>#${anime.rank || \"N/A\"}</td>\n                                <td>${anime.score || \"N/A\"}</td>\n                                <td>${anime.rating || \"N/A\"}</td>\n                            </tr>\n                        </tbody>\n                    </table>\n                    <h3>Beskrivning</h3>\n                    <p>${anime.synopsis || \"N/A\"}</p>\n                </div>\n            </article>`;\n    });\n}\n// Hämtar top anime från Jikan API, argumentet (page) i parametern ser till en och samma anime inte hämtas mer än en gång.\n// Varje sida innehåller max 10 anime då det ska finnas plats med överskrifter och text.\nasync function $5a3fc3e2587399e4$var$getTopAnime(page = 1) {\n    try {\n        const resp = await fetch(`https://api.jikan.moe/v4/top/anime?page=${page}&limit=10`);\n        if (resp.status === 429) {\n            alert(\"Maximalt antal f\\xf6rfr\\xe5gningar till API:n \\xe4r begr\\xe4nsad, men alla f\\xf6reg\\xe5ende sidor som redan h\\xe4mtas fungerar som normalt.\");\n            return;\n        }\n        const data = await resp.json();\n        sessionStorage.setItem(\"page\", JSON.stringify({\n            current: page,\n            last: data.pagination.last_visible_page\n        })); // Sätter/uppdaterar vilken sida användaren står på.\n        $5a3fc3e2587399e4$var$animePagesofLists(page, data.data); // Anropar för att ordna en array som ska lagras i sessionStorage.\n    } catch (error) {\n        console.error(error);\n    }\n}\n// Skapar objekt med två egenskaper:\n// page är som ett id som håller reda på vilken lista som den innehåller. Detta är för att vi endast hämtar en liten del av en gigantisk lista av anime.\n// list är den lista som tillhör page, i detta faller är det 10 list items.\nasync function $5a3fc3e2587399e4$var$animePagesofLists(page, animeList) {\n    if (sessionStorage.getItem(\"animePagesofLists\")) {\n        const pagesofLists = JSON.parse(sessionStorage.getItem(\"animePagesofLists\"));\n        pagesofLists.push({\n            page: page,\n            list: animeList\n        });\n        sessionStorage.setItem(\"animePagesofLists\", JSON.stringify(pagesofLists));\n    } else sessionStorage.setItem(\"animePagesofLists\", JSON.stringify([\n        {\n            page: page,\n            list: animeList\n        }\n    ]));\n}\n// Sökfältet, det är 500ms delay för att inte överstiga API:ns begränsade request rate.\nlet $5a3fc3e2587399e4$var$timeout;\n$5a3fc3e2587399e4$var$searchFIELD.addEventListener(\"input\", ()=>{\n    clearTimeout($5a3fc3e2587399e4$var$timeout);\n    $5a3fc3e2587399e4$var$timeout = setTimeout(async ()=>{\n        // Om fältet är tomt kommer användaren hamna på sidan den var på innan sökningen.\n        if ($5a3fc3e2587399e4$var$searchFIELD.value.trim() === \"\") {\n            if (sessionStorage.getItem(\"page\")) {\n                const pageData = JSON.parse(sessionStorage.getItem(\"page\"));\n                $5a3fc3e2587399e4$var$pageNumberSPAN.innerHTML = pageData.current;\n                $5a3fc3e2587399e4$var$maxPageSPAN.innerHTML = pageData.last;\n                $5a3fc3e2587399e4$var$renderList(pageData.current); // <---- Sätter vilken sida användaren ska ställas på.\n            }\n        } else {\n            // Hämtar en lista av tio anime som kan motsvara förfrågan.\n            const list = await $5a3fc3e2587399e4$var$searchAnime($5a3fc3e2587399e4$var$searchFIELD.value.trim());\n            // Anropar funktionen som renderar en lista.\n            $5a3fc3e2587399e4$var$listOnPage(list);\n        }\n    }, 500);\n});\n// Tar emot söktermen från sökfältet och söker i API:n. Returnerar en lista av 10 animes som motsvarar den sökta termen.\nasync function $5a3fc3e2587399e4$var$searchAnime(query) {\n    try {\n        const resp = await fetch(`https://api.jikan.moe/v4/anime?q=${query}&limit=10`);\n        const data = await resp.json();\n        return data.data;\n    } catch (error) {\n        console.error(error);\n    }\n}\n// Till föregående sida.\n$5a3fc3e2587399e4$var$prevBTN.addEventListener(\"click\", ()=>{\n    if (sessionStorage.getItem(\"page\")) {\n        const pageData = JSON.parse(sessionStorage.getItem(\"page\"));\n        // Stegar bakåt i en loop. Om användaren står på sida 1 blir föregående sida sista sidan med hjälp av if-satsen nedan.\n        let prevPage = (pageData.current - 1 + pageData.last) % pageData.last;\n        // Sista sidan blir pageData.last % pageData.last men det blir 0 och det finns inte och för att sista sidan ska bli möjlig måste sida 0 vara sista sidan. \n        if (prevPage == 0) prevPage = pageData.last;\n        sessionStorage.setItem(\"page\", JSON.stringify({\n            current: prevPage,\n            last: pageData.last\n        })); // Sätter/uppdaterar vilken sida användaren står på.\n        $5a3fc3e2587399e4$var$renderList(prevPage); // Renderar listan.\n    }\n});\n// Till nästa sida.\n$5a3fc3e2587399e4$var$nextBTN.addEventListener(\"click\", ()=>{\n    if (sessionStorage.getItem(\"page\")) {\n        const pageData = JSON.parse(sessionStorage.getItem(\"page\"));\n        // Stegar frammåt i en loop. Precis som ovanstående funktion men åt andra hållet.\n        let nextPage = (pageData.current + 1) % pageData.last;\n        if (nextPage == 0) nextPage = pageData.last;\n        sessionStorage.setItem(\"page\", JSON.stringify({\n            current: nextPage,\n            last: pageData.last\n        })); // Sätter/uppdaterar vilken sida användaren står på.\n        $5a3fc3e2587399e4$var$renderList(nextPage); // Renderar listan.\n    }\n});\n\n})();\n//# sourceMappingURL=index.9e1b9537.js.map\n","import \"@fontsource/roboto\"; // Normal\r\nimport \"@fontsource/roboto/700.css\"; // Bold\r\n\r\nconst prevBTN = document.getElementById(\"prev-btn\");\r\nconst nextBTN = document.getElementById(\"next-btn\");\r\nconst searchFIELD = document.getElementById(\"search-field\");\r\nconst pageNumberSPAN = document.getElementById(\"page-number\");\r\nconst maxPageSPAN = document.getElementById(\"max-pages\");\r\nconst animeListDIV = document.getElementById(\"anime-list\");\r\n\r\n// När sidan laddas in hämtas och renderas första sidan av anime listan.\r\nwindow.onload = async () => {\r\n    if (!sessionStorage.getItem(\"animePagesofLists\")) {\r\n        await getTopAnime();\r\n    }\r\n    // Sätter visuellt vilken sida som användaren står på vid inladdning av sidan.\r\n    if (sessionStorage.getItem(\"page\")) {\r\n        const pageData = JSON.parse(sessionStorage.getItem(\"page\"));\r\n        pageNumberSPAN.innerHTML = pageData.current;\r\n        maxPageSPAN.innerHTML = pageData.last;\r\n    }\r\n\r\n    renderList();\r\n}\r\n\r\n// Renderar en sida beroende på vilken sida det är, standard är första sidan.\r\nasync function renderList(page = 1) {\r\n    // Uppdaterar visuellt vilken sida användaren står på.\r\n    if (sessionStorage.getItem(\"page\")) {\r\n        const pageData = JSON.parse(sessionStorage.getItem(\"page\"));\r\n        pageNumberSPAN.innerHTML = pageData.current;\r\n        maxPageSPAN.innerHTML = pageData.last;\r\n    }\r\n    if (sessionStorage.getItem(\"animePagesofLists\")) {\r\n        // Hämtar listan från sessionStorage:\r\n        const pagesofLists = JSON.parse(sessionStorage.getItem(\"animePagesofLists\"));\r\n        // Loopar igenom sidorna tills rätt sida är funnen, då anropas listOnPage med sidans lista som argument, därefter stoppas loopen.\r\n        // Ifall sidlistan inte hittas i arrayen, då hämtas den sidlistan genom att anropa getTopAnime(sidnummer) och därefter renderas den nya sidlistan.\r\n        for (const list of pagesofLists) {\r\n            if (list.page === page) {\r\n                listOnPage(list.list);\r\n                break;\r\n            } else if (pagesofLists.indexOf(list) === pagesofLists.length - 1 && list.page !== page) {\r\n                await getTopAnime(page);\r\n                await renderList(page);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// Renderar en lista.\r\nfunction listOnPage(list) {\r\n    // Använder innerHTML för att det ska bli så smidigt som möjligt.\r\n    animeListDIV.innerHTML = \"\";\r\n    list.forEach(anime => {\r\n        let title = anime.title_english;\r\n        if (anime.title_english === null) {\r\n            title = anime.title;\r\n        }\r\n        animeListDIV.innerHTML +=\r\n            `<article class=anime-list-item>\r\n                <h2>${title}</h2>\r\n                <div>\r\n                    <picture class=poster>\r\n                        <source srcset=\"${anime.images.webp.image_url}\" type=\"image/webp\">\r\n                        <img src=\"${anime.images.jpg.image_url}\" width=\"100\" height=\"141\" alt=\"\" loading=\"lazy\" class=poster>\r\n                    </picture>\r\n                    <table class=anime-info-table>\r\n                        <thead>\r\n                            <tr>\r\n                                <th>Rank</th>\r\n                                <th>Score</th>\r\n                                <th>Rating</th>\r\n                            </tr>\r\n                        </thead>\r\n                        <tbody>\r\n                            <tr>\r\n                                <td>#${anime.rank || \"N/A\"}</td>\r\n                                <td>${anime.score || \"N/A\"}</td>\r\n                                <td>${anime.rating || \"N/A\"}</td>\r\n                            </tr>\r\n                        </tbody>\r\n                    </table>\r\n                    <h3>Beskrivning</h3>\r\n                    <p>${anime.synopsis || \"N/A\"}</p>\r\n                </div>\r\n            </article>`;\r\n    });\r\n}\r\n\r\n// Hämtar top anime från Jikan API, argumentet (page) i parametern ser till en och samma anime inte hämtas mer än en gång.\r\n// Varje sida innehåller max 10 anime då det ska finnas plats med överskrifter och text.\r\nasync function getTopAnime(page = 1) {\r\n    try {\r\n        const resp = await fetch(`https://api.jikan.moe/v4/top/anime?page=${page}&limit=10`);\r\n        if (resp.status === 429) {\r\n            alert(\"Maximalt antal förfrågningar till API:n är begränsad, men alla föregående sidor som redan hämtas fungerar som normalt.\");\r\n            return;\r\n        }\r\n        const data = await resp.json();\r\n\r\n        sessionStorage.setItem(\"page\", JSON.stringify({ current: page, last: data.pagination.last_visible_page })); // Sätter/uppdaterar vilken sida användaren står på.\r\n        animePagesofLists(page, data.data); // Anropar för att ordna en array som ska lagras i sessionStorage.\r\n    } catch (error) {\r\n        console.error(error);\r\n    }\r\n}\r\n\r\n// Skapar objekt med två egenskaper:\r\n// page är som ett id som håller reda på vilken lista som den innehåller. Detta är för att vi endast hämtar en liten del av en gigantisk lista av anime.\r\n// list är den lista som tillhör page, i detta faller är det 10 list items.\r\nasync function animePagesofLists(page, animeList) {\r\n    if (sessionStorage.getItem(\"animePagesofLists\")) {\r\n        const pagesofLists = JSON.parse(sessionStorage.getItem(\"animePagesofLists\"));\r\n        pagesofLists.push({ page: page, list: animeList });\r\n        sessionStorage.setItem(\"animePagesofLists\", JSON.stringify(pagesofLists));\r\n    } else {\r\n        sessionStorage.setItem(\"animePagesofLists\", JSON.stringify([{ page: page, list: animeList }]));\r\n    }\r\n}\r\n\r\n// Sökfältet, det är 500ms delay för att inte överstiga API:ns begränsade request rate.\r\nlet timeout;\r\nsearchFIELD.addEventListener(\"input\", () => {\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(async () => {\r\n        // Om fältet är tomt kommer användaren hamna på sidan den var på innan sökningen.\r\n        if (searchFIELD.value.trim() === \"\") {\r\n            if (sessionStorage.getItem(\"page\")) {\r\n                const pageData = JSON.parse(sessionStorage.getItem(\"page\"));\r\n                pageNumberSPAN.innerHTML = pageData.current;\r\n                maxPageSPAN.innerHTML = pageData.last;\r\n                renderList(pageData.current); // <---- Sätter vilken sida användaren ska ställas på.\r\n            }\r\n        } else {\r\n            // Hämtar en lista av tio anime som kan motsvara förfrågan.\r\n            const list = await searchAnime(searchFIELD.value.trim());\r\n            // Anropar funktionen som renderar en lista.\r\n            listOnPage(list);\r\n        }\r\n    }, 500);\r\n});\r\n\r\n// Tar emot söktermen från sökfältet och söker i API:n. Returnerar en lista av 10 animes som motsvarar den sökta termen.\r\nasync function searchAnime(query) {\r\n    try {\r\n        const resp = await fetch(`https://api.jikan.moe/v4/anime?q=${query}&limit=10`);\r\n        const data = await resp.json();\r\n\r\n        return data.data;\r\n    } catch (error) {\r\n        console.error(error);\r\n    }\r\n}\r\n\r\n// Till föregående sida.\r\nprevBTN.addEventListener(\"click\", () => {\r\n    if (sessionStorage.getItem(\"page\")) {\r\n        const pageData = JSON.parse(sessionStorage.getItem(\"page\"));\r\n        // Stegar bakåt i en loop. Om användaren står på sida 1 blir föregående sida sista sidan med hjälp av if-satsen nedan.\r\n        let prevPage = (pageData.current - 1 + pageData.last) % pageData.last;\r\n        // Sista sidan blir pageData.last % pageData.last men det blir 0 och det finns inte och för att sista sidan ska bli möjlig måste sida 0 vara sista sidan. \r\n        if (prevPage == 0) {\r\n            prevPage = pageData.last;\r\n        }\r\n        sessionStorage.setItem(\"page\", JSON.stringify({ current: prevPage, last: pageData.last })); // Sätter/uppdaterar vilken sida användaren står på.\r\n        renderList(prevPage); // Renderar listan.\r\n    }\r\n});\r\n\r\n// Till nästa sida.\r\nnextBTN.addEventListener(\"click\", () => {\r\n    if (sessionStorage.getItem(\"page\")) {\r\n        const pageData = JSON.parse(sessionStorage.getItem(\"page\"));\r\n        // Stegar frammåt i en loop. Precis som ovanstående funktion men åt andra hållet.\r\n        let nextPage = (pageData.current + 1) % pageData.last;\r\n        if (nextPage == 0) {\r\n            nextPage = pageData.last;\r\n        }\r\n        sessionStorage.setItem(\"page\", JSON.stringify({ current: nextPage, last: pageData.last })); // Sätter/uppdaterar vilken sida användaren står på.\r\n        renderList(nextPage); // Renderar listan.\r\n    }\r\n});\r\n"],"names":["$5a3fc3e2587399e4$var$timeout","$5a3fc3e2587399e4$var$prevBTN","document","getElementById","$5a3fc3e2587399e4$var$nextBTN","$5a3fc3e2587399e4$var$searchFIELD","$5a3fc3e2587399e4$var$pageNumberSPAN","$5a3fc3e2587399e4$var$maxPageSPAN","$5a3fc3e2587399e4$var$animeListDIV","$5a3fc3e2587399e4$var$renderList","page","sessionStorage","getItem","pageData","JSON","parse","innerHTML","current","last","pagesofLists","list","$5a3fc3e2587399e4$var$listOnPage","indexOf","length","$5a3fc3e2587399e4$var$getTopAnime","forEach","anime","title","title_english","images","webp","image_url","jpg","rank","score","rating","synopsis","resp","fetch","status","alert","data","json","setItem","stringify","pagination","last_visible_page","$5a3fc3e2587399e4$var$animePagesofLists","error","console","animeList","push","$5a3fc3e2587399e4$var$searchAnime","query","window","onload","addEventListener","clearTimeout","setTimeout","value","trim","prevPage","nextPage"],"version":3,"file":"index.9e1b9537.js.map"}